import { parseTree, Node } from 'jsonc-parser';
import { SourceMapGenerator } from 'source-map';
import bannedNames from './bannedNames';

type LanguageType = { [key: string]: LanguageType | Set<string> }

type LanguageDefinition = { [key: string]: LanguageDefinitionKey }
type LanguageDefinitionKey = LanguageDefinition | string

export type GenerateCommonOptions = {
  defaultLanguage?: string;
  errOnUnusedParam?: boolean;
  emitGitIgnore?: boolean;
} & ({
  emitUtils: false;
  emitBrowser: false;
} | {
  emitUtils?: true;
  emitBrowser?: boolean;
})

export type GenerateCoreOptions = { inputFiles: Files } & GenerateCommonOptions

export type Files = { name: string, content: string }[]

export const generateCore = ({
  inputFiles,
  defaultLanguage = 'en',
  errOnUnusedParam = false,
  emitGitIgnore = true,
  emitUtils = true,
  emitBrowser = true,
}: GenerateCoreOptions): Files => {
  const outputFiles: Files = [];

  if (new Set(inputFiles.map((f) => f.name)).size !== inputFiles.length) {
    throw new Error('Duplicate input file name');
  }

  const defaultLanguageFile = inputFiles.find((f) => f.name.slice(0, -5) === defaultLanguage);
  if (!defaultLanguageFile) {
    throw new Error(`Default language file does not exist (expected ${defaultLanguage}.json)`);
  }

  const smGen = new SourceMapGenerator({ file: 'types.d.ts' });

  const languageType: LanguageType = inputFiles.reduce<LanguageType>((acc, file) => {
    if (!file.name.endsWith('.json')) throw new Error(`Input file names must end with .json, but received ${file.name}`);
    const parsedContent = parseTree(file.content);
    if (!parsedContent) throw new Error(`Invalid JSON in ${file.name}`);

    const code = generateCode(parsedContent, acc, smGen, file === defaultLanguageFile);
    outputFiles.push({ name: `${file.name.slice(0, -5)}.ts`, content: code });
    return acc;
  }, {});

  // TODO: check the default language meets the language type (we might get this for free with TS? not sure - need to check)
  // i.e. assertThat(generateLanguageType(defaultLanguageFile)).isSubTypeOf(languageType)

  outputFiles.push({ name: 'types.ts', content: generateTypes(languageType, { errOnUnusedParam, includePlurals: false }) });

  if (emitUtils) outputFiles.push({ name: 'utils.ts', content: generateUtils({ inputFiles, defaultLanguage }) });
  if (emitBrowser) outputFiles.push({ name: 'browser.ts', content: generateBrowser() });
  if (emitGitIgnore) outputFiles.push({ name: '.gitignore', content: `${outputFiles.map((f) => f.name).join('\n')}\n.gitignore` });

  return outputFiles;
};

// Checks an object is a valid language definition, throwing if it isn't one
const asLanguageDefinition = (obj: unknown, errorIn?: string): LanguageDefinition => {
  if (Array.isArray(obj)) {
    throw new Error(`Invalid language definition as found array${errorIn ? ` (in ${errorIn})` : ''}`);
  }

  if (typeof obj !== 'object') {
    throw new Error(`Invalid language definition as found ${typeof obj}${errorIn ? ` (in ${errorIn})` : ''}`);
  }

  Object.entries(obj as { [key: string]: unknown }).forEach(([key, value]) => {
    if (!/[a-zA-Z_$][0-9a-zA-Z_$]*/.test(key)) throw new Error(`Invalid language definition due to bad key: '${key}'${errorIn ? ` (in ${errorIn})` : ''}`);

    if (typeof value !== 'string') {
      asLanguageDefinition(value, errorIn);
    }
  });

  return obj as LanguageDefinition;
};

/**
 * @param language The parsed language definition
 * @param languageType The constraints on the language type. Will be modified by this function.
 * @param isDefault Whether this is the default language
 * @returns code for the given language definition
 */
const generateCode = (language: Node, type: LanguageType, smGen: SourceMapGenerator, isDefault: boolean): string => (
  `// Do not edit directly, this is generated by ts-i18n
/* eslint-disable */
import { Language${isDefault ? '' : ', DeepPartial'} } from "./types"
const lang = ${generateCodeFragment(language, type, smGen, isDefault)}
export default lang as ${(isDefault ? 'Language' : 'DeepPartial<Language>')}\n`
);

/**
 * @param language A language definition
 * @param languageType The constraints on the language type. May be modified by this function.
 * @param path Path in the language definition we are at if this is a recursive call, to improve error messaging
 * @returns fragment of code for the given language definition, and updated constraints on the language type
 */
// TODO: check that the default language has all keys
/* eslint-disable no-param-reassign */
const generateCodeFragment = (language: Node, type: LanguageType, smGen: SourceMapGenerator, isDefault: boolean, path = '') => {
  let code = '';
  if (language.type === 'object') {
    const key: string = language.parent ? language.parent!.children![0].value : undefined;
    if (key) {
      type[key] = {};
      type = type[key] as LanguageType;
    }
    code += `{\n${indent(language.children!.map((c) => generateCodeFragment(c, type, smGen, isDefault, path)).join(',\n'))},\n}`;
  } else if (language.type === 'property') {
    code += `${generateCodeFragment(language.children![0], type, smGen, isDefault, path)}: ${generateCodeFragment(language.children![1], type as LanguageType, smGen, isDefault, `${path}.${language.children![0].value}`)}`;
  } else if (language.type === 'string' && language === language.parent!.children![0]) { // property key
    code += language.value;
  } else if (language.type === 'string' && language === language.parent!.children![1]) { // string value
    const stringified = JSON.stringify(language.value);

    // TODO: come up with a way of escaping parameters
    const params = [...new Set([...stringified.matchAll(/\{\{[a-zA-Z_$][0-9a-zA-Z_$]*\}\}/g)].map((match) => match[0].slice(2, -2)))];
    params.forEach((param) => {
      if (bannedNames.includes(param)) throw new Error(`Cannot use param name '${param}' as it is a reserved word`);
    });
    const key: string = language.parent!.children![0].value;
    const hasPlural = language.parent!.parent!.children!.some((c) => c.type === 'property' && c.children![0].value === `${key}_plural`);

    if (params.length && hasPlural) {
      const countRequired = params.includes('count');
      if (!countRequired) params.push('count');

      const parentPath = path.slice(0, path.lastIndexOf('.'));
      const body = `p.count === 1 ? (${stringified.replace(/\{\{([a-zA-Z_$][0-9a-zA-Z_$]*)\}\}/g, '" + p.$1.toString() + "')}) : lang${parentPath}.${key}_plural(p)`;
      code += `(p: { ${params.map((p) => (p === 'count' ? `${p + (countRequired ? '' : '?')}: number` : `${p}: string | number`)).join(', ')} }): string => ${body}`;
    } else if (params.length) {
      const body = stringified.replace(/\{\{([a-zA-Z_$][0-9a-zA-Z_$]*)\}\}/g, '" + p.$1.toString() + "');
      code += `(p: { ${params.map((p) => `${p}: string | number`).join(', ')} }): string => ${body}`;
    } else {
      code += `(): string => ${stringified}`;
    }

    const singularKey = key.endsWith('_plural') ? key.slice(0, -('_plural'.length)) : key;
    if (type[singularKey] === undefined) type[singularKey] = new Set(params);
    else if (type[singularKey] instanceof Set) params.forEach((p) => (type[singularKey] as Set<string>).add(p));
    else throw new Error(`Incompatible type, found both object and string at ${path}`);
  } else {
    throw new Error(`Unsupported type in language definition: ${language.type}`);
  }
  return code;
};

const generateTypes = (languageType: LanguageType, options: { errOnUnusedParam: boolean, includePlurals: boolean }) => (
  `${'// Do not edit directly, this is generated by ts-i18n\n'
  + '/* eslint-disable */\n'
  + 'export type DeepPartial<T> = { [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P]; }\n'
  + 'export interface Language '}${generateTypeFragment(languageType, options)}\n`
);

const generateTypeFragment = (languageType: LanguageType | Set<string>, options: { errOnUnusedParam: boolean, includePlurals: boolean }) => {
  let code = '';
  if (languageType instanceof Set && languageType.size === 0) {
    code += `(${options.errOnUnusedParam ? '' : 'p?: { [key: string]: string | number }'}) => string`;
  } else if (languageType instanceof Set) {
    code += `(p: { ${[...languageType].map((p) => (p === 'count' ? `${p}: number` : `${p}: string | number`)).join(', ')}${options.errOnUnusedParam ? '' : ', [key: string]: string | number'} }) => string`;
  } else {
    code += `{\n${indent(Object.entries(languageType).filter(([k, v]) => options.includePlurals || !k.endsWith('_plural')).map(([k, v]) => `${k}: ${generateTypeFragment(v, options)}`).join(',\n'))},\n}`;
  }
  return code;
};

const generateUtils = (options: { inputFiles: Files, defaultLanguage: string }) => `// Do not edit directly, this is generated by ts-i18n
/* eslint-disable */
${options.inputFiles.map((f) => `import ${f.name.slice(0, -5)} from './${f.name.slice(0, -5)}'\n`).join('')}import { Language, DeepPartial } from './types'

/**
 * Merges two languages together, preferring the preferred language where possible
 * @param preferredLang The preferred language. NB: may be modified
 * @param defaultLang The default language. NB: may be modified
 */
export const merge = (preferredLang: DeepPartial<Language>, defaultLang: Language): Language => {
  for (const key in defaultLang) {
    if (key in preferredLang) {
      if (typeof (preferredLang as any)[key] === 'object') {
        (preferredLang as any)[key] = merge((preferredLang as any)[key], (defaultLang as any)[key])
      }
    } else {
      (preferredLang as any)[key] = (defaultLang as any)[key]
    }
  }
  return preferredLang as Language
}

export const languages = { ${options.inputFiles.map((f) => f.name.slice(0, -5)).join(', ')} }

export const defaultLanguage = ${options.defaultLanguage}

export const defaultLanguageCode = ${JSON.stringify(options.defaultLanguage)}`;

const generateBrowser = () => `// Do not edit directly, this is generated by ts-i18n
/* eslint-disable */
import { merge, languages, defaultLanguage } from './utils'
import { Language } from './types'

// Preferred languages, as specified by the user's browser
const preferredLanguages =
  ((navigator.languages ? navigator.languages : [navigator.language]) ?? [])
    .flatMap(lang => lang.length > 2 ? [lang, lang.slice(0, 2)] : lang)
    .filter((l, i, arr) => arr.indexOf(l) === i)
    .slice(0, 25)

let language: Language = defaultLanguage // fallback language
for (let i = preferredLanguages.length; i > 0; i--) {
  const key = preferredLanguages[i] as keyof typeof languages
  if (key in languages) {
    language = merge(languages[key], language)
  }
}

export default language
`;

const indent = (str: string): string => str.split('\n').map((line) => (line.length ? `  ${line}` : line)).join('\n');
