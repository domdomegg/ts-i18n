import bannedNames from './bannedNames';

type LanguageType = { [key: string]: LanguageTypeKey }
type LanguageTypeKey = { type: 'object', values: LanguageType } | { type: 'string', params: Set<string> }

type LanguageDefinition = { [key: string]: LanguageDefinitionKey }
type LanguageDefinitionKey = LanguageDefinition | string

export type Files = { name: string, content: string }[]

export const generateCore = (options: {
  inputFiles: Files,
  defaultLanguage: string,
}): Files => {
  const outputFiles: Files = [];

  if (new Set(options.inputFiles.map((f) => f.name)).size !== options.inputFiles.length) {
    throw new Error('Duplicate input file name');
  }

  const defaultLanguageFile = options.inputFiles.find((f) => f.name.slice(0, -5) === options.defaultLanguage);
  if (!defaultLanguageFile) {
    throw new Error(`Default language file does not exist (expected ${options.defaultLanguage}.json)`);
  }

  const languageType: LanguageType = options.inputFiles.reduce<LanguageType>((acc, file) => {
    if (!file.name.endsWith('.json')) throw new Error(`Input file names must end with .json, but received ${file.name}`);
    const parsedContent = asLanguageDefinition(saferJSONParse(file.content, file.name), file.name);

    const { code, languageType } = generateCodeAndLanguageType(parsedContent, file === defaultLanguageFile, acc);
    outputFiles.push({ name: `${file.name.slice(0, -5)}.ts`, content: code });
    return languageType;
  }, {});

  // TODO: check the default language meets the language type (we might get this for free with TS? not sure - need to check)
  // i.e. assertThat(generateLanguageType(defaultLanguageFile)).isSubTypeOf(languageType)

  outputFiles.push({ name: 'types.ts', content: generateTypes(languageType, false) });
  outputFiles.push({ name: 'utils.ts', content: generateUtils(options) });
  outputFiles.push({ name: 'browser.ts', content: generateBrowser() });
  outputFiles.push({ name: '.gitignore', content: `${outputFiles.map((f) => f.name).join('\n')}\n.gitignore` });

  return outputFiles;
};

const saferJSONParse = (str: string, errorIn?: string) => {
  try {
    return JSON.parse(str);
  } catch {
    throw new Error(`Failed to pass JSON${errorIn ? ` (in ${errorIn})` : ''}`);
  }
};

// Checks an object is a valid language definition, throwing if it isn't one
const asLanguageDefinition = (obj: unknown, errorIn?: string): LanguageDefinition => {
  if (Array.isArray(obj)) {
    throw new Error(`Invalid language definition as found array${errorIn ? ` (in ${errorIn})` : ''}`);
  }

  if (typeof obj !== 'object') {
    throw new Error(`Invalid language definition as found ${typeof obj}${errorIn ? ` (in ${errorIn})` : ''}`);
  }

  Object.entries(obj as { [key: string]: unknown }).forEach(([key, value]) => {
    if (!/[a-zA-Z_$][0-9a-zA-Z_$]*/.test(key)) throw new Error(`Invalid language definition due to bad key: '${key}'${errorIn ? ` (in ${errorIn})` : ''}`);

    if (typeof value !== 'string') {
      asLanguageDefinition(value, errorIn);
    }
  });

  return obj as LanguageDefinition;
};

/**
 * @param language The parsed language definition
 * @param isDefault Whether this is the default language
 * @param languageType The constraints on the language type. May be modified by this function.
 * @returns code for the given language definition, and updated constraints on the language type
 */
// TODO: possibly extract the language type generation
const generateCodeAndLanguageType = (language: LanguageDefinition, isDefault: boolean, languageType: LanguageType = {}): { code: string, languageType: LanguageType } => ({
  code: `// Do not edit directly, this is generated by ts-i18n
/* eslint-disable */
import { Language${isDefault ? '' : ', DeepPartial'} } from "./types"
const lang = {${indent(generateCodeFragment(language, languageType))}\n}
export default lang as ${(isDefault ? 'Language' : 'DeepPartial<Language>')}\n`,
  languageType,
});

/**
 * @param language A language definition
 * @param languageType The constraints on the language type. May be modified by this function.
 * @param path Path in the language definition we are at if this is a recursive call, to improve error messaging
 * @returns fragment of code for the given language definition, and updated constraints on the language type
 */
// TODO: general tidy up, and possibly extract the language type generation
/* eslint-disable no-param-reassign */
const generateCodeFragment = (language: LanguageDefinition, languageType: LanguageType, path = '') => {
  let code = '';
  Object.entries(language).forEach(([key, languageValue]) => {
    if (typeof languageValue === 'object') {
      if (languageType[key] === undefined) {
        languageType[key] = { type: 'object', values: {} };
      }

      const languageTypeKey = languageType[key];
      if (languageTypeKey.type !== 'object') {
        throw new Error(`Incompatible type at ${path}, some translation files define objects and others define strings`);
      }

      code += `\n${key}: {${indent(generateCodeFragment(languageValue, languageTypeKey.values, path.length ? `${path}[${JSON.stringify(key)}]` : JSON.stringify(key)))}\n},`;
    } else {
      if (languageType[key] === undefined) {
        languageType[key] = { type: 'string', params: new Set() };
      }

      const languageTypeKey = languageType[key];
      if (languageTypeKey.type !== 'string') {
        throw new Error(`Incompatible type at ${path}, some translation files define objects and others define strings`);
      }

      const stringified = JSON.stringify(languageValue);

      // TODO: come up with a way of escaping parameters
      const params = [...new Set([...stringified.matchAll(/\{\{[a-zA-Z_$][0-9a-zA-Z_$]*\}\}/g)].map((match) => match[0].slice(2, -2)))];
      params.forEach((param) => {
        if (bannedNames.includes(param)) throw new Error(`Cannot use param name '${param}' as it is a reserved word`);
      });
      if (params.length && `${key}_plural` in language) {
        const countRequired = params.includes('count');
        if (!countRequired) params.push('count');

        const body = `p.count === 1 ? (${stringified.replace(/\{\{([a-zA-Z_$][0-9a-zA-Z_$]*)\}\}/g, '" + p.$1.toString() + "')}) : lang.${path}${key}_plural(p)`;
        code += `\n${key}: (p: { ${params.map((p) => (p === 'count' ? `${p + (countRequired ? '' : '?')}: number` : `${p}: string | number`)).join(', ')} }): string => ${body},`;
      } else if (params.length) {
        const body = stringified.replace(/\{\{([a-zA-Z_$][0-9a-zA-Z_$]*)\}\}/g, '" + p.$1.toString() + "');
        code += `\n${key}: (p: { ${params.map((p) => `${p}: string | number`).join(', ')} }): string => ${body},`;
      } else {
        code += `\n${key}: (): string => ${stringified},`;
      }

      params.forEach((param) => languageTypeKey.params.add(param));
    }
  });
  return code;
};

const generateTypes = (languageType: LanguageType, includePlurals = true) => (
  `${'// Do not edit directly, this is generated by ts-i18n\n'
  + '/* eslint-disable */\n'
  + 'export type DeepPartial<T> = { [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P]; }\n'
  + 'export interface Language {'}${indent(generateTypeFragment(languageType, includePlurals))}\n}\n`
);

const generateTypeFragment = (languageType: LanguageType, includePlurals: boolean) => {
  let code = '';
  Object.entries(languageType).forEach(([key, languageTypeKey]) => {
    if (languageTypeKey.type === 'object') {
      code += `\n${key}: {${indent(generateTypeFragment(languageTypeKey.values, includePlurals))}\n},`;
    } else if (!includePlurals && key.endsWith('_plural')) {
      // noop
    } else if (languageTypeKey.params.size === 0) {
      code += `\n${key}: () => string,`;
    } else {
      code += `\n${key}: (p: { ${[...languageTypeKey.params].map((p) => (p === 'count' ? `${p}: number` : `${p}: string | number`)).join(', ')} }) => string,`;
    }
  });
  return code;
};

const generateUtils = (options: { inputFiles: Files, defaultLanguage: string }) => `// Do not edit directly, this is generated by ts-i18n
/* eslint-disable */
${options.inputFiles.map((f) => `import ${f.name.slice(0, -5)} from './${f.name.slice(0, -5)}'\n`).join('')}import { Language, DeepPartial } from './types'

/**
 * Merges two languages together, preferring the preferred language where possible
 * @param preferredLang The preferred language. NB: may be modified
 * @param defaultLang The default language. NB: may be modified
 */
export const merge = (preferredLang: DeepPartial<Language>, defaultLang: Language): Language => {
  for (const key in defaultLang) {
    if (key in preferredLang) {
      if (typeof (preferredLang as any)[key] === 'object') {
        (preferredLang as any)[key] = merge((preferredLang as any)[key], (defaultLang as any)[key])
      }
    } else {
      (preferredLang as any)[key] = (defaultLang as any)[key]
    }
  }
  return preferredLang as Language
}

export const languages = { ${options.inputFiles.map((f) => f.name.slice(0, -5)).join(', ')} }

export const defaultLanguage = ${options.defaultLanguage}

export const defaultLanguageCode = ${JSON.stringify(options.defaultLanguage)}`;

const generateBrowser = () => `// Do not edit directly, this is generated by ts-i18n
/* eslint-disable */
import { merge, languages, defaultLanguage } from './generated/index'
import { Language } from './generated/types'

// Preferred languages, as specified by the user's browser
const preferredLanguages =
  ((navigator.languages ? navigator.languages : [navigator.language]) ?? [])
    .flatMap(lang => lang.length > 2 ? [lang, lang.slice(0, 2)] : lang)
    .filter((l, i, arr) => arr.indexOf(l) === i)
    .slice(0, 25)

let language: Language = defaultLanguage // fallback language
for (let i = preferredLanguages.length; i > 0; i--) {
  const key = preferredLanguages[i] as keyof typeof languages
  if (key in languages) {
    language = merge(languages[key], language)
  }
}

export default language
`;

const indent = (str: string): string => str.split('\n').map((line) => (line.length ? `  ${line}` : line)).join('\n');
