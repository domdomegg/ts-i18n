import { bannedNames } from "./bannedNames";

type LanguageType = { [key: string]: LanguageTypeKey };
type LanguageTypeKey =
  | { type: "object"; values: LanguageType }
  | { type: "string"; params: Set<string> };

type LanguageDefinition = { [key: string]: LanguageDefinitionKey };
type LanguageDefinitionKey = LanguageDefinition | string;

export type Files = { name: string; content: string }[];

export const generateCore = (options: {
  inputFiles: Files;
  defaultLanguage: string;
}): Files => {
  const outputFiles: Files = [];

  if (
    new Set(options.inputFiles.map((f) => f.name)).size !==
    options.inputFiles.length
  ) {
    throw new Error("Duplicate input file name");
  }

  const defaultLanguageFile = options.inputFiles.find(
    (f) => f.name.slice(0, -5) === options.defaultLanguage
  );
  if (!defaultLanguageFile) {
    throw new Error(
      "Default language file does not exist (expected " +
        options.defaultLanguage +
        ".json)"
    );
  }

  const languageType: LanguageType = options.inputFiles.reduce<LanguageType>(
    (acc, file) => {
      if (!file.name.endsWith(".json"))
        throw new Error(
          "Input file names must end with .json, but received " + file.name
        );
      const parsedContent = asLanguageDefinition(
        saferJSONParse(file.content, file.name),
        file.name
      );

      const { code, languageType } = generateCodeAndLanguageType(
        parsedContent,
        file === defaultLanguageFile,
        acc
      );
      outputFiles.push({ name: file.name.slice(0, -5) + ".ts", content: code });
      return languageType;
    },
    {}
  );

  // TODO: check the default language meets the language type (we might get this for free with TS? not sure - need to check)
  // i.e. assertThat(generateLanguageType(defaultLanguageFile)).isSubTypeOf(languageType)

  outputFiles.push({
    name: "types.ts",
    content: generateTypes(languageType, false),
  });
  outputFiles.push({ name: "index.ts", content: generateIndex(options) });

  return outputFiles;
};

const saferJSONParse = (str: string, errorIn?: string) => {
  try {
    return JSON.parse(str);
  } catch {
    throw new Error(
      "Failed to pass JSON" + errorIn ? " (in " + errorIn + ")" : ""
    );
  }
};

// Checks an object is a valid language definition, throwing if it isn't one
const asLanguageDefinition = (
  obj: any,
  errorIn?: string
): LanguageDefinition => {
  if (Array.isArray(obj)) {
    throw new Error(
      "Invalid language definition as found array" + errorIn
        ? " (in " + errorIn + ")"
        : ""
    );
  }

  if (typeof obj !== "object") {
    throw new Error(
      "Invalid language definition as found " + typeof obj + errorIn
        ? " (in " + errorIn + ")"
        : ""
    );
  }

  for (let key in obj) {
    if (!/[a-zA-Z_$][0-9a-zA-Z_$]*/.test(key))
      throw new Error(
        "Invalid language definition due to bad key: '" + key + "'" + errorIn
          ? " (in " + errorIn + ")"
          : ""
      );

    if (typeof obj[key] !== "string") {
      asLanguageDefinition(obj[key], errorIn);
    }
  }

  return obj as LanguageDefinition;
};

/**
 * @param language The parsed language definition
 * @param isDefault Whether this is the default language
 * @param languageType The constraints on the language type. May be modified by this function.
 * @returns code for the given language definition, and updated constraints on the language type
 */
// TODO: possibly extract the language type generation
const generateCodeAndLanguageType = (
  language: LanguageDefinition,
  isDefault: boolean,
  languageType: LanguageType = {}
): { code: string; languageType: LanguageType } => ({
  code: `// Do not edit directly, this is generated by ts-i18n
/* eslint-disable */
import { Language${isDefault ? "" : ", DeepPartial"} } from "./types"
const lang = {${indent(generateCodeFragment(language, languageType))}\n}
export default lang as ${isDefault ? "Language" : "DeepPartial<Language>"}\n`,
  languageType,
});

/**
 * @param language A language definition
 * @param languageType The constraints on the language type. May be modified by this function.
 * @param path Path in the language definition we are at if this is a recursive call, to improve error messaging
 * @returns fragment of code for the given language definition, and updated constraints on the language type
 */
// TODO: general tidy up, and possibly extract the language type generation
const generateCodeFragment = (
  language: LanguageDefinition,
  languageType: LanguageType,
  path = ""
) => {
  let code = "";
  for (const key in language) {
    const value = language[key];

    if (typeof value == "object") {
      if (languageType[key] === undefined) {
        languageType[key] = { type: "object", values: {} };
      }

      const languageTypeKey = languageType[key];
      if (languageTypeKey.type !== "object") {
        throw new Error(
          "Incompatible type at " +
            path +
            ", some translation files define objects and others define strings"
        );
      }

      code +=
        "\n" +
        key +
        ": {" +
        indent(
          generateCodeFragment(
            value,
            languageTypeKey.values,
            path.length
              ? path + "[" + JSON.stringify(key) + "]"
              : JSON.stringify(key)
          )
        ) +
        "\n},";
    } else if (typeof value == "string") {
      if (languageType[key] === undefined) {
        languageType[key] = { type: "string", params: new Set() };
      }

      const languageTypeKey = languageType[key];
      if (languageTypeKey.type !== "string") {
        throw new Error(
          "Incompatible type at " +
            path +
            ", some translation files define objects and others define strings"
        );
      }

      const stringified = JSON.stringify(value);

      // TODO: come up with a way of escaping parameters
      const params = [
        ...new Set(
          [...stringified.matchAll(/\{\{[a-zA-Z_$][0-9a-zA-Z_$]*\}\}/g)].map(
            (match) => match[0].slice(2, -2)
          )
        ),
      ];
      for (const param of params) {
        if (bannedNames.includes(param))
          throw new Error(
            "Cannot use param name '" + param + "' as it is a reserved word"
          );
      }
      if (params.length && key + "_plural" in language) {
        let countRequired = params.includes("count");
        if (!countRequired) params.push("count");

        const body =
          "p.count === 1 ? (" +
          stringified.replace(
            /\{\{([a-zA-Z_$][0-9a-zA-Z_$]*)\}\}/g,
            '" + p.$1.toString() + "'
          ) +
          ") : lang." +
          path +
          key +
          "_plural(p)";
        code +=
          "\n" +
          key +
          ": (p: { " +
          params
            .map((p) =>
              p === "count"
                ? p + (countRequired ? "" : "?") + ": number"
                : p + ": string | number"
            )
            .join(", ") +
          " }): string => " +
          body +
          ",";
      } else if (params.length) {
        const body = stringified.replace(
          /\{\{([a-zA-Z_$][0-9a-zA-Z_$]*)\}\}/g,
          '" + p.$1.toString() + "'
        );
        code +=
          "\n" +
          key +
          ": (p: { " +
          params.map((p) => p + ": string | number").join(", ") +
          " }): string => " +
          body +
          ",";
      } else {
        code += "\n" + key + ": (): string => " + stringified + ",";
      }

      for (const param of params) languageTypeKey.params.add(param);
    } else {
      throw new Error(
        "Values of type " +
          typeof value +
          " are not supported in translation files, but was found at " +
          path
      );
    }
  }
  return code;
};

const generateTypes = (
  languageType: LanguageType,
  includePlurals: boolean = true
) =>
  "// Do not edit directly, this is generated by ts-i18n\n" +
  "/* eslint-disable */\n" +
  "export type DeepPartial<T> = { [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P]; }\n" +
  "export interface Language {" +
  indent(generateTypeFragment(languageType, includePlurals)) +
  "\n}\n";

const generateTypeFragment = (
  languageType: LanguageType,
  includePlurals: boolean
) => {
  let code = "";
  for (const key in languageType) {
    const languageTypeKey = languageType[key];
    if (languageTypeKey.type == "object") {
      code +=
        "\n" +
        key +
        ": {" +
        indent(generateTypeFragment(languageTypeKey.values, includePlurals)) +
        "\n},";
    } else if (languageTypeKey.type == "string") {
      if (!includePlurals && key.endsWith("_plural")) {
        // noop
      } else if (languageTypeKey.params.size == 0) {
        code += "\n" + key + ": () => string,";
      } else {
        code +=
          "\n" +
          key +
          ": (p: { " +
          [...languageTypeKey.params]
            .map((p) =>
              p === "count" ? p + ": number" : p + ": string | number"
            )
            .join(", ") +
          " }) => string,";
      }
    } else {
      throw new Error("Unexpected type " + (languageTypeKey as any).type);
    }
  }
  return code;
};

const generateIndex = (options: {
  inputFiles: Files;
  defaultLanguage: string;
}) => {
  return `// Do not edit directly, this is generated by ts-i18n
/* eslint-disable */
${options.inputFiles
  .map(
    (f) =>
      "import " +
      f.name.slice(0, -5) +
      " from './" +
      f.name.slice(0, -5) +
      "'\n"
  )
  .join("")}import { Language, DeepPartial } from './types'

/**
 * Merges two languages together, preferring the preferred language where possible
 * @param preferredLang The preferred language. NB: may be modified
 * @param defaultLang The default language. NB: may be modified
 */
export const merge = (preferredLang: DeepPartial<Language>, defaultLang: Language): Language => {
  for (const key in defaultLang) {
    if (key in preferredLang) {
      if (typeof (preferredLang as any)[key] === 'object') {
        (preferredLang as any)[key] = merge((preferredLang as any)[key], (defaultLang as any)[key])
      }
    } else {
      (preferredLang as any)[key] = (defaultLang as any)[key]
    }
  }
  return preferredLang as Language
}

export const languages = { ${options.inputFiles
    .map((f) => f.name.slice(0, -5))
    .join(", ")} }

export const defaultLanguage = ${JSON.stringify(options.defaultLanguage)}`;
};

const indent = (str: string): string =>
  str
    .split("\n")
    .map((line) => (line.length ? "  " + line : line))
    .join("\n");
